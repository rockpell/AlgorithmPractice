# 가장 먼 노드

https://programmers.co.kr/learn/courses/30/lessons/49189?language=cpp

현재 비효율적인 코드, 개선 

```c++
#include <string>
#include <vector>
#include <algorithm>
#include <string.h>

using namespace std;

class Graph
{
private:
	const int cost = 1;
	const int maxValue = 210000000;

	bool** map;
	bool* visited;
	int size;

	vector<int> dist;

public:
	Graph(int n)
	{
		size = n + 1;
		dist.resize(size);
		visited = new bool[size];
		map = new bool*[size];

		for(int i = 0; i < size; i++)
		{
			map[i] = new bool[size];
			memset(map[i], 0, sizeof(bool)*size);

			dist[i] = 210000000;
			visited[i] = false;
		}
	}
	~Graph()
	{
		for (int i = 0; i < size; i++)
		{
			delete[] map[i];
		}
		delete[] map;
		delete[] visited;
	}

	void inputVertex(vector<vector<int>> edge);
	void setStartVertex(int start);
	vector<int> dijkstra();
};

void Graph::inputVertex(vector<vector<int>> edge)
{
	for(auto& item : edge)
	{
		map[item[0]][item[1]] = true;
		map[item[1]][item[0]] = true;
	}
}

void Graph::setStartVertex(int start)
{
	visited[start] = true;
	dist[start] = 0;
}

vector<int> Graph::dijkstra()
{
	for (int i = 1; i < size; i++) {
		int minValue = maxValue;
		int minIndex = 1;

		for (int p = 1; p < size; p++) { // 방문 안한 노드 중 최소값 찾기
			if (!visited[p]) {
				if (dist[p] < minValue) {
					minIndex = p;
					minValue = dist[p];
				}
			}
		}

		visited[minIndex] = true;

		for (int p = 1; p < size; p++) { // 인점 정점 중 가장 짧은 경로 찾기
			if (map[minIndex][p]) {
				if (dist[p] > dist[minIndex] + cost)
					dist[p] = dist[minIndex] + cost;
			}
		}
	}
	return dist;
}

int solution(int n, vector<vector<int>> edge)
{
	int answer = 0;
	vector<int> dist;
	Graph graph(n);

	graph.inputVertex(edge);
	graph.setStartVertex(1);
	dist = graph.dijkstra();

	sort(dist.begin(), dist.end());

	int sameValueTarget = dist[dist.size() - 2];

	for(int i = (int)dist.size() - 2; i >= 0; --i)
	{
		if(sameValueTarget == dist[i])
		{
			++answer;
		}
		else
		{
			break;
		}
	}

	return answer;
}
```
